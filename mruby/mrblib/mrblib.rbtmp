#
#  Array
#
class Array
  # 15.2.12.5.10
  def each(&block)
    idx = 0
    while(idx < length)
      block.call(self[idx])
      idx += 1
    end
    self
  end

  # 15.2.12.5.11
  def each_index(&block)
    idx = 0
    while(idx < length)
      block.call(idx)
      idx += 1
    end
    self
  end

  # 15.2.12.5.7
  def collect!(&block)
    self.each_index{|idx|
      self[idx] = block.call(self[idx])
    }
    self
  end

  # 15.2.12.5.20
  # map!(&block)
  alias map! collect!

  # 15.2.12.5.15
  def initialize(size=0, obj=nil, &block)
    raise TypeError, "expected Integer for 1st argument" unless size.kind_of? Integer
    raise ArgumentError, "negative array size" if size < 0

    self.clear
    if size > 0
      self[size - 1] = nil  # allocate

      idx = 0
      while(idx < size)
        self[idx] = (block)? block.call(idx): obj
        idx += 1
      end
    end

    self
  end

  def delete(key, &block)
    while i = self.index(key)
      self.delete_at(i)
      ret = key
    end
    if ret == nil && block
      block.call
    else
      ret
    end
  end
end

# include modules
module Enumerable; end
module Comparable; end
class Array
  include Enumerable
  include Comparable

  def sort!(&block)
    self.replace(self.sort(&block))
  end
end
### move to compar.c
# module Comparable
  # def == other
  #   cmp = self <=> other
  #   if cmp == 0
  #     true
  #   else
  #     false
  #   end
  # end

  # def < other
  #   cmp = self <=> other
  #   if cmp.nil?
  #     false
  #   elsif cmp < 0
  #     true
  #   else
  #     false
  #   end
  # end

  # def <= other
  #   cmp = self <=> other
  #   if cmp.nil?
  #     false
  #   elsif cmp <= 0
  #     true
  #   else
  #     false
  #   end
  # end

  # def > other
  #   cmp = self <=> other
  #   if cmp.nil?
  #     false
  #   elsif cmp > 0
  #     true
  #   else
  #     false
  #   end
  # end

  # def >= other
  #   cmp = self <=> other
  #   if cmp.nil?
  #     false
  #   elsif cmp >= 0
  #     true
  #   else
  #     false
  #   end
  # end

  # def between?(min,max)
  #   if self < min or self > max
  #     false
  #   else
  #     true
  #   end
  # end
# end
#
#  Enumerable
#
module Enumerable
  # 15.3.2.2.1
  def all?(&block)
    st = true
    if block
      self.each{|val|
        unless block.call(val)
          st = false
          break
        end
      }
    else
      self.each{|val|
        unless val
          st = false
          break
        end
      }
    end
    st
  end

  # 15.3.2.2.2
  def any?(&block)
    st = false
    if block
      self.each{|val|
        if block.call(val)
          st = true
          break
        end
      }
    else
      self.each{|val|
        if val
          st = true
          break
        end
      }
    end
    st
  end

  # 15.3.2.2.3
  def collect(&block)
    ary = []
    self.each{|val|
      ary.push(block.call(val))
    }
    ary
  end

  # 15.3.2.2.4
  def detect(ifnone=nil, &block)
    ret = ifnone
    self.each{|val|
      if block.call(val)
        ret = val
        break
      end
    }
    ret
  end

  # 15.3.2.2.5
  def each_with_index(&block)
    i = 0
    self.each{|val|
      block.call(val, i)
      i += 1
    }
    self
  end

  # 15.3.2.2.6
  def entries
    ary = []
    self.each{|val|
      ary.push val
    }
    ary
  end

  # 15.3.2.2.7
  # find(ifnone=nil, &block)
  alias find detect

  # 15.3.2.2.8
  def find_all(&block)
    ary = []
    self.each{|val|
      ary.push(val) if block.call(val)
    }
    ary
  end

  # 15.3.2.2.9
  def grep(pattern, &block)
    ary = []
    self.each{|val|
      if pattern === val
        ary.push((block)? block.call(val): val)
      end
    }
    ary
  end

  # 15.3.2.2.10
  def include?(obj)
    st = false
    self.each{|val|
      if val == obj
        st = true
        break
      end
    }
    st
  end

  # 15.3.2.2.11
  def inject(*args, &block)
    raise ArgumentError, "too many arguments" if args.size > 2
    flag = true  # 1st element?
    result = nil
    self.each{|val|
      if flag
        # 1st element
        result = (args.empty?)? val: block.call(args[0], val)
        flag = false
      else
        result = block.call(result, val)
      end
    }
    result
  end

  # 15.3.2.2.12
  # map(&block)
  alias map collect

  # 15.3.2.2.13
  def max(&block)
    flag = true  # 1st element?
    result = nil
    self.each{|val|
      if flag
        # 1st element
        result = val
        flag = false
      else
        if block
          result = val if block.call(val, result) > 0
        else
          result = val if (val <=> result) > 0
        end
      end
    }
    result
  end

  # 15.3.2.2.14
  def min(&block)
    flag = true  # 1st element?
    result = nil
    self.each{|val|
      if flag
        # 1st element
        result = val
        flag = false
      else
        if block
          result = val if block.call(val, result) < 0
        else
          result = val if (val <=> result) < 0
        end
      end
    }
    result
  end

  # 15.3.2.2.15
  # member?(obj)
  alias member? include?

  # 15.3.2.2.16
  def partition(&block)
    ary_T = []
    ary_F = []
    self.each{|val|
      if block.call(val)
        ary_T.push(val)
      else
        ary_F.push(val)
      end
    }
    [ary_T, ary_F]
  end

  # 15.3.2.2.17
  def reject(&block)
    ary = []
    self.each{|val|
      ary.push(val) unless block.call(val)
    }
    ary
  end

  # 15.3.2.2.18
  # select(&block)
  alias select find_all


  # Does this OK? Please test it.
  def __sort_sub__(sorted, work, src_ary, head, tail, &block)
    if head == tail
      sorted[head] = work[head] if src_ary == 1
      return
    end

    # on current step, which is a src ary?
    if src_ary == 0
      src, dst = sorted, work
    else
      src, dst = work, sorted
    end

    key = src[head]    # key value for dividing values
    i, j = head, tail  # position to store on the dst ary

    (head + 1).upto(tail){|idx|
      if ((block)? block.call(src[idx], key): (src[idx] <=> key)) > 0
        # larger than key
        dst[j] = src[idx]
        j -= 1
      else
        dst[i] = src[idx]
        i += 1
      end
    }

    sorted[i] = key

    # sort each sub-array
    src_ary = (src_ary + 1) % 2  # exchange a src ary
    __sort_sub__(sorted, work, src_ary, head, i - 1, &block) if i > head
    __sort_sub__(sorted, work, src_ary, i + 1, tail, &block) if i < tail
  end
#  private :__sort_sub__

  # 15.3.2.2.19
  def sort(&block)
    ary = []
    self.each{|val| ary.push(val)}
    unless ary.empty?
      __sort_sub__(ary, ::Array.new(ary.size), 0, 0, ary.size - 1, &block)
    end
    ary
  end

  # 15.3.2.2.20
  # to_a
  alias to_a entries
end
#
#  Exception
#
class Exception
  # 15.2.22.4.1
  def self.exception(*args, &block)
    self.new(*args, &block)
  end
end
#
#  Hash
#
class Hash
  # 15.2.13.4.8
  def delete(key, &block)
    if block && ! self.has_key?(key)
      block.call(key)
    else
      self.__delete(key)
    end
  end

  # 15.2.13.4.9
  def each(&block)
    self.keys.each{|k| block.call([k, self[k]])}
    self
  end

  # 15.2.13.4.10
  def each_key(&block)
    self.keys.each{|k| block.call(k)}
    self
  end

  # 15.2.13.4.11
  def each_value(&block)
    self.keys.each{|k| block.call(self[k])}
    self
  end

  # 15.2.13.4.16
  def initialize(*args, &block)
    self.__init_core(block, *args)
  end

  # 15.2.13.4.22
  def merge(other, &block)
    h = {}
    raise "can't convert argument into Hash" unless other.respond_to?(:to_hash)
    other = other.to_hash
    self.each_key{|k| h[k] = self[k]}
    if block
      other.each_key{|k|
        h[k] = (self.has_key?(k))? block.call(k, self[k], other[k]): other[k]
      }
    else
      other.each_key{|k| h[k] = other[k]}
    end
    h
  end
end

# include modules
module Enumerable; end
class Hash
  include Enumerable
end
#
#  Kernel
#
module Kernel
  # 15.3.1.2.6
  def self.lambda(&block)
    ### *** TODO *** ###
    block  # dummy
  end

  # 15.3.1.2.8
  def self.loop #(&block)
    while(true)
      yield
    end
  end

  # 15.3.1.3.4
  def __send__(symbol, *args, &block)
    ### *** TODO *** ###
  end

  # 15.3.1.3.18
  def instance_eval(string=nil, &block)
    ### *** TODO *** ###
  end

  # 15.3.1.3.27
  def lambda(&block)
    ### *** TODO *** ###
    block # dummy
  end

  # 15.3.1.3.29
  def loop #(&block)
    while(true)
      yield
    end
  end

  # 15.3.1.3.44
  def send(symbol, *args, &block)
    ### *** TODO *** ###
  end
end
#
#  Integer
#
class Integer
  # 15.2.8.3.15
  def downto(num, &block)
    raise TypeError, "expected Integer" unless num.kind_of? Integer
    i = self
    while(i >= num)
      block.call(i)
      i -= 1
    end
    self
  end

  # 15.2.8.3.22
  def times(&block)
    i = 0
    while(i < self)
      block.call(i)
      i += 1
    end
    self
  end

  # 15.2.8.3.27
  def upto(num, &block)
    raise TypeError, "expected Integer" unless num.kind_of? Integer
    i = self
    while(i <= num)
      block.call(i)
      i += 1
    end
    self
  end
end

# include modules
module Comparable; end
class Numeric
  include Comparable
end
module Kernel
  def print(*args)
    i = 0
    len = args.size
    while i < len
      __printstr__ args[i].to_s
      i += 1
    end
  end
  def puts(*args)
    i = 0
    len = args.size
    while i < len
      __printstr__ args[i].to_s
      __printstr__ "\n"
      i += 1
    end
    __printstr__ "\n" if len == 0
  end
end
#
#  Range
#
class Range
  # 15.2.14.4.4
  def each(&block)
    val = self.first
    unless val.respond_to? :succ
      raise TypeError, "can't iterate"
    end

    last = self.last
    return self if (val <=> last) > 0

    while((val <=> last) < 0)
      block.call(val)
      val = val.succ
    end

    block.call(val) unless exclude_end?

    self
  end
end

# include modules
module Enumerable; end
class Range
  include Enumerable
end
#
#  String
#
class String
  # 15.2.10.5.15
  def each_line(&block)
    # expect that str.index accepts an Integer for 1st argument as a byte data
    offset = 0
    while(pos = self.index(0x0a, offset))
      block.call(self[offset, pos + 1 - offset])
      offset = pos + 1
    end
    block.call(self[offset, self.size - offset]) if self.size > offset
    self
  end

  # 15.2.10.5.18
  def gsub(*args, &block)
    unless (args.size == 1 && block) || args.size == 2
      raise ArgumentError, "wrong number of arguments"
    end

    ### *** TODO *** ###
  end

  # 15.2.10.5.19
  def gsub!(*args, &block)
    str = self.gsub(*args, &block)
    if str != self
      self.replace(str)
      self
    else
      nil
    end
  end

  # 15.2.10.5.32
  def scan(reg, &block)
    ### *** TODO *** ###
  end

  # 15.2.10.5.36
  def sub(*args, &block)
    unless (args.size == 1 && block) || args.size == 2
      raise ArgumentError, "wrong number of arguments"
    end

    ### *** TODO *** ###
  end

  # 15.2.10.5.37
  def sub!(*args, &block)
    str = self.sub(*args, &block)
    if str != self
      self.replace(str)
      self
    else
      nil
    end
  end

  def each_char(&block)
    pos = 0
    while(pos < self.size)
      block.call(self[pos])
      pos += 1
    end
    self
  end

  def each_byte(&block)
    bytes = self.unpack("C*")
    pos = 0
    while(pos < bytes.size)
      block.call(bytes[pos])
      pos += 1
    end
    self
  end

  def []=(pos, value)
    b = self[0, pos]
    a = self[pos+1..-1]
    p [b, value, a].join('')
    self.replace([b, value, a].join(''))
  end
end

# include modules
module Comparable; end
class String
  include Comparable
end
#
#  Struct
#
class Struct
  # 15.2.18.4.4
  def each(&block)
    self.class.members.each{|field|
      block.call(self[field])
    }
    self
  end

  # 15.2.18.4.5
  def each_pair(&block)
    self.class.members.each{|field|
      block.call(field.to_sym, self[field])
    }
    self
  end

  # 15.2.18.4.7
  def select(&block)
    ary = []
    self.class.members.each{|field|
      val = self[field]
      ary.push(val) if block.call(val)
    }
    ary
  end
end
